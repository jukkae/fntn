<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Three.js fountain playground</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/TessellateModifier.js"></script>
    <script src="util/fbo.js"></script> <!-- should be imported ofc -->
    <script src="util/GeometryUtils.js"></script>
    <script type="x-shader/x-vertex" id="vertexShader">
      uniform float time;
      uniform float scale;
      uniform float timeFactor;
      uniform float amplitudeFactor;
      uniform float circularAmplitudeFactor;
      
      uniform float wavelengths[6];
      uniform float amplitudes[6];
      uniform float speeds[6];
      uniform vec2 directions[6];

      uniform float circularWavelength;
      uniform float circularSpeed;
      uniform float circularWaveStrengths[2];
      uniform vec2 circularWaveCenterPoints[2];
      
      varying vec3 vColor;
      varying vec3 worldNormal;
      varying vec3 vViewPosition;
      varying vec3 eyeDirection;
      varying vec3 vWorldPos;

      const float pi = 3.14159;

      // sine function is a bit too smooth to look realistic
      // --> move to nonnegative and raise to kth exponent
      float modSin(float x) {
        float k = 1.6;
        return 2.0 * pow(((sin(x)+1.0)/2.0), k);
      }
      
      float wave(int i, float x, float y) {
        float frequency = 2.0 * pi / wavelengths[i];
        float phase = speeds[i] * frequency;
        float theta = dot(directions[i], vec2(x, y));
        return scale * amplitudes[i] * amplitudeFactor * modSin(theta * frequency + time * timeFactor * phase);
      }

      float waveHeight(float x, float y) {
        float height = 0.0;
        for(int i = 0; i < 6; i++) {
          height += wave(i, x, y);
        }
        return height;
      }

      float dWavedx(int i, float x, float y) {
        float frequency = 2.0*pi/wavelengths[i];
        float phase = speeds[i] * frequency;
        float theta = dot(directions[i], vec2(x, y));
        float A = amplitudes[i] * amplitudeFactor * directions[i].x * frequency;
        return A * cos(theta * frequency + time * timeFactor * phase);
      }

      float dWavedy(int i, float x, float y) {
        float frequency = 2.0*pi/wavelengths[i];
        float phase = speeds[i] * frequency;
        float theta = dot(directions[i], vec2(x, y));
        float A = amplitudes[i] * amplitudeFactor * directions[i].y * frequency;
        return A * cos(theta * frequency + time * timeFactor * phase);
      }

      float circularWave(int i, float x, float y) {
        vec2 vertex = vec2(x, y);
        vec2 center = circularWaveCenterPoints[i];
        float frequency = 2.0 * pi / circularWavelength;
        float phaseSpeed = circularSpeed * frequency;
        vec2 waveDir = normalize(vertex - center);
        float distance = distance(vertex, center);
        float distanceFactor = clamp(10.0 - distance, 0.0, 10.0);
        float theta = dot(waveDir, vertex);

        float A = circularWaveStrengths[i] * scale * distanceFactor * circularAmplitudeFactor;
        return A * cos(theta * sqrt(pow((vertex.x - center.x), 2.0) + pow((vertex.y - center.y), 2.0)) + (time * -timeFactor * phaseSpeed)
          );
      }

      float circularWaveHeight(float x, float y) {
        float height = 0.0;
        for(int i = 0; i < 2; i++) {
          height += circularWave(i, x, y);
        }
        return height;
      }

      float dCircularWavedx(int i, float x, float y) {
        vec2 vertex = vec2(x, y);
        vec2 center = circularWaveCenterPoints[i];
        float frequency = 2.0 * pi / circularWavelength;
        float phaseSpeed = circularSpeed * frequency;
        vec2 waveDir = normalize(vertex - center);
        float distance = distance(vertex, center);
        float distanceFactor = clamp(10.0 - distance, 0.0, 10.0);
        float theta = dot(waveDir, vertex);

        float A = circularWaveStrengths[i] * scale * distanceFactor * circularAmplitudeFactor * waveDir.x * frequency;
        return A * cos(theta * sqrt(pow((vertex.x - center.x), 2.0) + pow((vertex.y - center.y), 2.0)) + (time * -timeFactor * phaseSpeed)
          );
      }

      float dCircularWavedy(int i, float x, float y) {
        vec2 vertex = vec2(x, y);
        vec2 center = circularWaveCenterPoints[i];
        float frequency = 2.0 * pi / circularWavelength;
        float phaseSpeed = circularSpeed * frequency;
        vec2 waveDir = normalize(vertex - center);
        float distance = distance(vertex, center);
        float distanceFactor = clamp(10.0 - distance, 0.0, 10.0);
        float theta = dot(waveDir, vertex);

        float A = circularWaveStrengths[i] * scale * distanceFactor * circularAmplitudeFactor * waveDir.y * frequency;
        return A * cos(theta * sqrt(pow((vertex.x - center.x), 2.0) + pow((vertex.y - center.y), 2.0)) + (time * -timeFactor * phaseSpeed)
          );
      }

      vec3 waveNormal(float x, float y) {
        float dx = 0.0;
        float dy = 0.0;
        for (int i = 0; i < 6; i++) {
            dx += dWavedx(i, x, y);
            dy += dWavedy(i, x, y);
        }
        vec3 n = vec3(-dx, -dy, 1.0);
        return n;
        //return normalize(n);
      }

      vec3 circularWaveNormal(float x, float y) {
        float dx = 0.0;
        float dy = 0.0;
        for (int i = 0; i < 2; i++) {
          dx += dCircularWavedx(i, x, y);
          dy += dCircularWavedy(i, x, y);
        }
        vec3 n = vec3(-dx, -dy, 1.0);
        return n;
        //return normalize(n);
      }

      void main(void) {
        vColor = vec3((position.x+5.0)/10.0, (position.y+5.0)/10.0, 1);
        vec4 viewModelPosition = modelViewMatrix * vec4( position, 1 );
        vViewPosition = viewModelPosition.xyz;
        eyeDirection = normalize(vViewPosition - position);
        
        vec3 posNew = position;
        vWorldPos = position;
        posNew.z += waveHeight(position.x, position.y);
        posNew.z += circularWaveHeight(position.x, position.y);
        vec3 wn = waveNormal(position.x, position.y);
        vec3 cwn = circularWaveNormal(position.x, position.y);
        worldNormal = normalize(wn+cwn);
        //worldNormal = normalize(cwn);
        gl_Position = projectionMatrix * modelViewMatrix * vec4( posNew, 1.0 );
      }
    </script>
    <script type="x-shader/x-fragment" id="fragmentShader">
      varying vec3 vColor;
      varying vec3 vViewPosition;
      varying vec3 worldNormal;
      varying vec3 eyeDirection;
      varying vec3 vWorldPos;

      struct PointLight {
        vec3 position;
        vec3 color;
      };
      uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

      void main() {
        vec4 addedLights = vec4(0.0, 0.0, 0.0, 1.0);
        vec3 lightDirection = normalize(vWorldPos - pointLights[0].position);
        addedLights.rgb += clamp(dot(-lightDirection, worldNormal), 0.0, 1.0) * pointLights[0].color;
        //addedLights.rgb = pointLights[0].color;
        for(int l = 0; l < NUM_POINT_LIGHTS; l++) {
          vec3 adjustedLight = pointLights[l].position + cameraPosition;
          vec3 lightDirection = normalize(vWorldPos - adjustedLight);
          addedLights.rgb += clamp(dot(lightDirection, worldNormal), 0.0, 1.0) * pointLights[l].color;
        }

        //vec3 r = reflect(eyeDirection, worldNormal);
        vec3 r = vec3(0.5, 0.8, 1.0);
        float alpha = clamp(dot(-eyeDirection, worldNormal), 0.0, 1.0);
        vec4 c = vec4(r, 0.5 + (alpha / 2.0));
        //gl_FragColor = vec4(vColor.rgb, 0.7);
        gl_FragColor = c * addedLights;
      }
    </script>
    <script type="x-shader/x-vertex" id="simulationVertexShader">
     varying vec2 vUv; // cursor to texture
      void main() {
          vUv = position.xy;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>
    <script type="x-shader/x-fragment" id="simulationFragmentShader">

      uniform sampler2D positions;
      uniform sampler2D origin;
      uniform float timer;
      uniform float radius;

      varying vec2 vUv;

      uniform float orderTimer;
      uniform float explodeTimer;

      const float PI = 3.1415926535897932384626433832795;

      //this is exactly the same as in glsl-random
      float rand(vec2 co){
        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
      }

      void main() {
          vec3 pos;
          vec3 originPos;
              
          pos = texture2D( positions, vUv ).rgb;
          originPos = texture2D( origin, vUv ).rgb;

          pos += originPos;
          if(length(pos) > 10.0) pos = originPos;
          
          gl_FragColor = vec4( pos, 1.0 );
      }
    </script>
    <script type="x-shader/x-vertex" id="renderVertexShader">
      //float texture containing the positions of each particle
      uniform sampler2D positions;
      uniform sampler2D origin;

      attribute vec2 reference;
      varying vec3 vColor;

      uniform float pointSize;
      uniform float radius;

      uniform int boom;

      void main() {

          //the mesh is a nomrliazed square so the uvs = the xy positions of the vertices
          vec3 pos = texture2D( positions, reference).xyz;

          // Distance from center?
          /*
          vColor = vec3(distToCenter, 0.5, 0.5);
          */

          vColor = vec3(1.0, reference);
          if (boom == 1) {
              float distToCenter = distance(pos, vec3(0, 0, 0)) / (radius);
              vColor.g += (25.0 - distToCenter) / 65.0;
              vColor.b += (25.0 - distToCenter) / 65.0;
          }

          gl_Position = projectionMatrix *  modelViewMatrix * vec4( pos, 1.0 );
          gl_PointSize = pointSize;

      }
    </script>
    <script type="x-shader/x-fragment" id="renderFragmentShader">
      varying vec3 vColor;

      void main() {
        //gl_FragColor = vec4( vec3( 1., .5, .5 ), .85 );
        gl_FragColor = vec4(vColor, 1.);
        //gl_FragColor = vec4(1., 0., 1., 1.);
      }
    </script>
    <script>
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
      camera.position.z = 15;
      camera.position.y = -15;
      camera.lookAt(new THREE.Vector3(0,0,0));

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );


      var defMaterial = new THREE.MeshPhongMaterial ( {
        color: 0xaaaaaa
      } );

      var sphere = new THREE.SphereGeometry( 1 );
      var lightCue = new THREE.Mesh( sphere, defMaterial );
      lightCue.position.set( 11, 11, 6 );
      scene.add(lightCue);

      var pointLight = new THREE.PointLight( 0xaaffaa, 0.8 );
      pointLight.position.set( 10, 10, 5 );
      scene.add( pointLight );

      var lightCue2 = new THREE.Mesh( sphere, defMaterial );
      lightCue2.position.set( 0, 0, 9 );
      scene.add(lightCue2);

      var pointLight2 = new THREE.PointLight( 0xffaaaa, 0.8 );
      pointLight2.position.set( 0, 0, 8 );
      scene.add( pointLight2 );

      var circularWaveStrength1 = Math.random();
      var circularWaveStrength2 = Math.random();

      // wave uniforms are basically arbitrary
      var uniforms = THREE.UniformsUtils.merge([
        THREE.UniformsLib['lights'],
        {
          time: { type: "f", value: 0.0 },
          timeFactor: { type: "f", value: 1.5 },
          amplitudeFactor: { type: "f", value: 0.5 },
          circularAmplitudeFactor: {type: "f", value: 0.02 },
          scale: { type: "f", value: 0.5 },
          wavelengths: { type: "f[]", value: [8.0, 5.0, 3.2, 2.1, 1.7, 1.3] },
          speeds: { type: "f[]", value: [0.4, 0.43, 0.47, 0.5, 0.8, 0.9] },
          amplitudes: { type: "f[]", value: [0.5, 0.45, 0.3, 0.23, 0.17, 0.05] },
          directions: { type: "v2[]", value: [
            new THREE.Vector2 ( 1.0, 0.0 ).normalize(),
            new THREE.Vector2 ( 0.5, 0.5 ).normalize(),
            new THREE.Vector2 ( 0.4, 0.7 ).normalize(),
            new THREE.Vector2 ( 0.8, 0.2 ).normalize(),
            new THREE.Vector2 ( 1.0, 0.3 ).normalize(),
            new THREE.Vector2 ( 0.0, 0.4 ).normalize()
          ] },
          circularWavelength: { type: "f", value: 1.0 },
          circularSpeed: { type: "f", value: 1.0 },
          circularWaveStrengths: { type: "f[]", value: [circularWaveStrength1, circularWaveStrength2] },
          circularWaveCenterPoints: { type: "v2[]", value: [
            new THREE.Vector2 ( 10.0, 0.0 ),
            new THREE.Vector2 ( 0.0, 5.0 )
          ] }
        }
      ]);
      
      var positions = initParticles();

      function initParticles() {
        let fboGeo = sphere;
        var noOfParticles = 1000;

        let data = new Float32Array( noOfParticles );

        let points = THREE.GeometryUtils.randomPointsInGeometry(fboGeo, noOfParticles );
        for ( var i = 0, j = 0, l = data.length; i < l; i += 3, j += 1 ) {
            data[ i ] = points[ j ].x;
            data[ i + 1 ] = points[ j ].y;
            data[ i + 2 ] = points[ j ].z;
        }
        //texture is a square
        let positions = new THREE.DataTexture( data, 1, 1, THREE.RGBFormat, THREE.FloatType );
        positions.needsUpdate = true;
        return positions;
      };

      var simulationShader = new THREE.ShaderMaterial( {
        uniforms: {
          positions: { type: "t", value: positions },
          origin: { type: "t", value: positions },
          timer: { type: "f", value: 0},
          radius: { type: "f", value: 10 },
          orderTimer: { type: "f", value: 0.0 },
          explodeTimer: { type: "f", value: 0.0 }
        },
        vertexShader: document.getElementById( 'simulationVertexShader' ).textContent,
        fragmentShader: document.getElementById( 'simulationFragmentShader' ).textContent
      } );

      var renderShader = new THREE.ShaderMaterial( {
          uniforms: {
              positions: { type: "t", value: null },
              pointSize: { type: "f", value: 10.0},
              radius: { type: "f", value: 10 },
              boom: { type: "1", value: 0 }
          },
          vertexShader: document.getElementById( 'renderVertexShader' ).textContent,
        fragmentShader: document.getElementById( 'renderFragmentShader' ).textContent,
          transparent: false
//            blending:THREE.AdditiveBlending
      } );

      var particleSubstrate = new THREE.Object3D();
      particleSubstrate.position.set( 0, 0, 3 );
      scene.add(particleSubstrate);

      function init() {
        // Particle geometry? Just once particle
        var particleGeometry  = new THREE.Geometry();
        particleGeometry.vertices.push( new THREE.Vector3() );
        fbo = new FBO();
        fbo.init( 1, 1, renderer, simulationShader, renderShader, particleGeometry );
        particleSubstrate.add( fbo.particles );
        fbo.update();
      }

      function update(dt, et) {
        simulationShader.uniforms.timer.value = et;
        fbo.update();

        if (simulationShader.uniforms.orderTimer.value > 0.3 && 
           simulationShader.uniforms.explodeTimer.value == 0.0) {
            this.rotateZ(0.5 * dt);
        }
      }

      var material = new THREE.ShaderMaterial( {
        uniforms: uniforms,
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
        transparent: true,
        lights: true
      } );   
      
      var size = 10;

      var circle = new THREE.CircleGeometry( size, 32 );

      var tessellateModifier = new THREE.TessellateModifier(.01);
      
      var tessellationDepth = 10;
      for(var i = 0; i < tessellationDepth; i++){
        tessellateModifier.modify(circle);
      }

      var pool = new THREE.Mesh( circle, material );
      scene.add( pool );

      var poolBottom = new THREE.Mesh( circle, defMaterial );
      scene.add( poolBottom );
      poolBottom.position.z = -5;

      controls = new THREE.OrbitControls( camera, renderer.domElement );

      var clock = new THREE.Clock();
      clock.start();

      function getRandomPoint() {
        dSquared = Math.random() * size * size;
        theta = Math.random() * Math.PI * 2;
        x = Math.sqrt(dSquared) * Math.cos(theta);
        y = Math.sqrt(dSquared) * Math.sin(theta);
        return new THREE.Vector2(x, y);
      }

      function render() {
        requestAnimationFrame( render );
        renderer.render( scene, camera );

        var delta = clock.getDelta();
        uniforms.time.value += delta;
        for(var i = 0; i < 2; i++){
          if(uniforms.circularWaveStrengths.value[i] > 0) {
            uniforms.circularWaveStrengths.value[i] -= (delta/10.0);
          } else {
            uniforms.circularWaveStrengths.value[i] = 1.0;
            var center = getRandomPoint();
            uniforms.circularWaveCenterPoints.value[i] = center;
          }
        }
        update(delta, clock.getElapsedTime());
      }
      init();
      render();
    </script>
  </body>
</html>

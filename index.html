<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Three.js fountain playground</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/TessellateModifier.js"></script>
    <script type="x-shader/x-vertex" id="vertexShader">
      #define MAX_POINT_LIGHTS 4

      uniform float time;
      uniform float scale;
      uniform float timeFactor;
      uniform float wavelengths[4];
      uniform float amplitudes[4];
      uniform float speeds[4];
      uniform vec2 directions[4];
      uniform vec3 pointLightColor[MAX_POINT_LIGHTS];
      uniform vec3 pointLightPosition[MAX_POINT_LIGHTS];
      uniform float pointLightDistance[MAX_POINT_LIGHTS];

      
      varying vec3 vColor;
      varying vec3 worldNormal;
      varying vec3 vViewPosition;
      varying vec3 eyeDirection;
      varying vec3 vWorldPos;

      const float pi = 3.14159;

      // sine function is a bit too smooth to look realistic
      // --> move to nonnegative and raise to kth exponent
      float modSin(float x) {
        float k = 1.8;
        return 2.0 * pow(((sin(x)+1.0)/2.0), k);
      }
      
      float wave(int i, float x, float y) {
        float frequency = 2.0 * pi / wavelengths[i];
        float phase = speeds[i] * frequency;
        float theta = dot(directions[i], vec2(x, y));
        return scale * amplitudes[i] * modSin(theta * frequency + time * timeFactor * phase);
      }

      float waveHeight(float x, float y) {
        float height = 0.0;
        for(int i = 0; i < 4; i++) {
          height += wave(i, x, y);
        }
        return height;
      }

      float dWavedx(int i, float x, float y) {
        float frequency = 2.0*pi/wavelengths[i];
        float phase = speeds[i] * frequency;
        float theta = dot(directions[i], vec2(x, y));
        float A = amplitudes[i] * directions[i].x * frequency;
        return A * cos(theta * frequency + time * phase);
      }

      float dWavedy(int i, float x, float y) {
        float frequency = 2.0*pi/wavelengths[i];
        float phase = speeds[i] * frequency;
        float theta = dot(directions[i], vec2(x, y));
        float A = amplitudes[i] * directions[i].y * frequency;
        return A * cos(theta * frequency + time * phase);
      }

      vec3 waveNormal(float x, float y) {
        float dx = 0.0;
        float dy = 0.0;
        for (int i = 0; i < 4; i++) {
            dx += dWavedx(i, x, y);
            dy += dWavedy(i, x, y);
        }
        vec3 n = vec3(-dx, -dy, 1.0);
        return normalize(n);
      }

      void main(void) {
        vColor = vec3((position.x+5.0)/10.0, (position.y+5.0)/10.0, 1);
        vec4 viewModelPosition = modelViewMatrix * vec4( position, 1 );
        vViewPosition = viewModelPosition.xyz;
        eyeDirection = normalize(vViewPosition - position);
        
        vec3 posNew = position;
        vWorldPos = position;
        posNew.z = waveHeight(position.x, position.y);
        worldNormal = waveNormal(position.x, position.y);
        gl_Position = projectionMatrix * modelViewMatrix * vec4( posNew, 1.0 );
      }
    </script>
    <script type="x-shader/x-fragment" id="fragmentShader">
      #define MAX_POINT_LIGHTS 4

      varying vec3 vColor;
      varying vec3 vViewPosition;
      varying vec3 worldNormal;
      varying vec3 eyeDirection;
      varying vec3 vWorldPos;

      uniform vec3 pointLightColor[MAX_POINT_LIGHTS];
      uniform vec3 pointLightPosition[MAX_POINT_LIGHTS];
      uniform float pointLightDistance[MAX_POINT_LIGHTS];

      void main() {
        vec4 addedLights = vec4(0.0, 0.0, 0.0, 1.0);
        vec3 lightDirection = normalize(vWorldPos - pointLightPosition[0]);
        addedLights.rgb += clamp(dot(-lightDirection, worldNormal), 0.0, 1.0) * pointLightColor[0];

        vec3 r = reflect(eyeDirection, worldNormal);
        vec4 c = vec4(r, 0.8);
        //gl_FragColor = vec4(vColor.rgb, 0.7);
        gl_FragColor = c * addedLights;
      }
    </script>
    <script>
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
      camera.position.z = 15;
      camera.position.y = -15;
      camera.lookAt(new THREE.Vector3(0,0,0));

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );

      // wave uniforms are basically arbitrary
      var uniforms = THREE.UniformsUtils.merge([
        THREE.UniformsLib['lights'],
        {
          time: { type: "f", value: 0.0 },
          timeFactor: { type: "f", value: 1.0 },
          scale: { type: "f", value: 0.5 },
          wavelengths: { type: "f[]", value: [10.0, 5.0, 3.0, 1.0] },
          speeds: { type: "f[]", value: [0.4, 0.6, 0.7, 1.0] },
          amplitudes: { type: "f[]", value: [1.0, 0.5, 0.4, 0.2] },
          directions: { type: "v2[]", value: [
            new THREE.Vector2 ( 1.0, 0.0 ),
            new THREE.Vector2 (-0.5, 0.5 ),
            new THREE.Vector2 ( 0.4, 0.7 ),
            new THREE.Vector2 ( 0.0, 0.1 )
          ] }
        }
      ]);
      
      var material = new THREE.ShaderMaterial( {
        uniforms: uniforms,
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
        transparent: true
      } );
      var size = 10;

      var circle = new THREE.CircleGeometry( size, 32 );

      var tessellateModifier = new THREE.TessellateModifier(.01);
      
      var tessellationDepth = 10;
      for(var i = 0; i < tessellationDepth; i++){
        tessellateModifier.modify(circle);
      }

      var pool = new THREE.Mesh( circle, material );
      scene.add( pool );

      var defMaterial = new THREE.MeshPhongMaterial ( {
        color: 0xaaaaaa
      } );

      var poolBottom = new THREE.Mesh( circle, defMaterial );
      scene.add( poolBottom );
      poolBottom.position.z = -5;

      var sphere = new THREE.SphereGeometry( 1 );
      var lightCue = new THREE.Mesh( sphere, defMaterial );
      lightCue.position.set( 2, 2, 11 );
      scene.add(lightCue);

      var pointLight = new THREE.PointLight( 0x00ff00, 1.0 );
      pointLight.position.set( 2, 2, 10 );
      scene.add( pointLight );

      controls = new THREE.OrbitControls( camera, renderer.domElement );

      var clock = new THREE.Clock();
      clock.start();

      function render() {
        requestAnimationFrame( render );
        renderer.render( scene, camera );

  var delta = clock.getDelta();
  uniforms.time.value += delta;
      }
      render();
    </script>
  </body>
</html>

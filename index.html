<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Three.js fountain playground</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/TessellateModifier.js"></script>
    <script type="x-shader/x-vertex" id="vertexShader">
      uniform float time;
      uniform float scale;
      uniform float timeFactor;
      uniform float amplitudeFactor;
      uniform float circularAmplitudeFactor;
      
      uniform float wavelengths[6];
      uniform float amplitudes[6];
      uniform float speeds[6];
      uniform vec2 directions[6];

      uniform float circularWavelength;
      uniform float circularSpeed;
      uniform float circularWaveStrengths[2];
      uniform vec2 circularWaveCenterPoints[2];
      
      varying vec3 vColor;
      varying vec3 worldNormal;
      varying vec3 vViewPosition;
      varying vec3 eyeDirection;
      varying vec3 vWorldPos;

      const float pi = 3.14159;

      // sine function is a bit too smooth to look realistic
      // --> move to nonnegative and raise to kth exponent
      float modSin(float x) {
        float k = 1.6;
        return 2.0 * pow(((sin(x)+1.0)/2.0), k);
      }
      
      float wave(int i, float x, float y) {
        float frequency = 2.0 * pi / wavelengths[i];
        float phase = speeds[i] * frequency;
        float theta = dot(directions[i], vec2(x, y));
        return scale * amplitudes[i] * amplitudeFactor * modSin(theta * frequency + time * timeFactor * phase);
      }

      float waveHeight(float x, float y) {
        float height = 0.0;
        for(int i = 0; i < 6; i++) {
          height += wave(i, x, y);
        }
        return height;
      }

      float dWavedx(int i, float x, float y) {
        float frequency = 2.0*pi/wavelengths[i];
        float phase = speeds[i] * frequency;
        float theta = dot(directions[i], vec2(x, y));
        float A = amplitudes[i] * amplitudeFactor * directions[i].x * frequency;
        return A * cos(theta * frequency + time * timeFactor * phase);
      }

      float dWavedy(int i, float x, float y) {
        float frequency = 2.0*pi/wavelengths[i];
        float phase = speeds[i] * frequency;
        float theta = dot(directions[i], vec2(x, y));
        float A = amplitudes[i] * amplitudeFactor * directions[i].y * frequency;
        return A * cos(theta * frequency + time * timeFactor * phase);
      }

      float circularWave(int i, float x, float y) {
        float frequency = 2.0 * pi / circularWavelength;
        float phase = circularSpeed * frequency;
        vec2 waveDir = normalize(vec2(x, y) - circularWaveCenterPoints[i]);
        float distance = distance(vec2(x, y), circularWaveCenterPoints[i]);
        float distanceFactor = clamp(10.0 - distance, 0.0, 10.0);
        float theta = dot(waveDir, vec2(x, y));

        float A = circularWaveStrengths[i] * scale * distanceFactor * circularAmplitudeFactor;
        return A * sin(theta * frequency + time * -timeFactor * phase);         
      }

      float circularWaveHeight(float x, float y) {
        float height = 0.0;
        for(int i = 0; i < 2; i++) {
          height += circularWave(i, x, y);
        }
        return height;
      }

      float dCircularWavedx(int i, float x, float y) {
        vec2 vertex = vec2(x, y);
        vec2 center = circularWaveCenterPoints[i];
        float frequency = 2.0 * pi / circularWavelength;
        float phase = circularSpeed * frequency;
        vec2 waveDir = normalize(vertex - center); // problems here
        float distance = distance(vertex, center);
        float distanceFactor = 10.0; //clamp(10.0 - distance, 0.0, 10.0);
        float theta = dot(waveDir, vertex); // or problems here

        float A = circularWaveStrengths[i] * scale * distanceFactor * circularAmplitudeFactor * waveDir.x * frequency;
        return A * cos((theta * frequency) + (time * -timeFactor * phase));
      }

      float dCircularWavedy(int i, float x, float y) {
        vec2 vertex = vec2(x, y);
        vec2 center = circularWaveCenterPoints[i];
        float frequency = 2.0 * pi / circularWavelength;
        float phase = circularSpeed * frequency;
        vec2 waveDir = normalize(vertex - center);
        float distance = distance(vertex, center);
        float distanceFactor = 10.0; //clamp(10.0 - distance, 0.0, 10.0);
        float theta = dot(waveDir, vertex);

        float A = circularWaveStrengths[i] * scale * distanceFactor * circularAmplitudeFactor * waveDir.y * frequency;
        return A * cos((theta * frequency) + (time * -timeFactor * phase));
      }

      vec3 waveNormal(float x, float y) {
        float dx = 0.0;
        float dy = 0.0;
        for (int i = 0; i < 6; i++) {
            dx += dWavedx(i, x, y);
            dy += dWavedy(i, x, y);
        }
        vec3 n = vec3(-dx, -dy, 1.0);
        return n;
        //return normalize(n);
      }

      vec3 circularWaveNormal(float x, float y) {
        float dx = 0.0;
        float dy = 0.0;
        for (int i = 0; i < 2; i++) {
          dx += dCircularWavedx(i, x, y);
          dy += dCircularWavedy(i, x, y);
        }
        vec3 n = vec3(-dx, -dy, 1.0);
        return n;
        //return normalize(n);
      }

      void main(void) {
        vColor = vec3((position.x+5.0)/10.0, (position.y+5.0)/10.0, 1);
        vec4 viewModelPosition = modelViewMatrix * vec4( position, 1 );
        vViewPosition = viewModelPosition.xyz;
        eyeDirection = normalize(vViewPosition - position);
        
        vec3 posNew = position;
        vWorldPos = position;
        //posNew.z += waveHeight(position.x, position.y);
        //posNew.z += circularWaveHeight(position.x, position.y);
        vec3 wn = waveNormal(position.x, position.y);
        vec3 cwn = circularWaveNormal(position.x, position.y);
        //worldNormal = normalize(wn+cwn);
        worldNormal = normalize(cwn);
        gl_Position = projectionMatrix * modelViewMatrix * vec4( posNew, 1.0 );
      }
    </script>
    <script type="x-shader/x-fragment" id="fragmentShader">
      varying vec3 vColor;
      varying vec3 vViewPosition;
      varying vec3 worldNormal;
      varying vec3 eyeDirection;
      varying vec3 vWorldPos;

      struct PointLight {
        vec3 position;
        vec3 color;
      };
      uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

      void main() {
        vec4 addedLights = vec4(0.0, 0.0, 0.0, 1.0);
        vec3 lightDirection = normalize(vWorldPos - pointLights[0].position);
        addedLights.rgb += clamp(dot(-lightDirection, worldNormal), 0.0, 1.0) * pointLights[0].color;
        //addedLights.rgb = pointLights[0].color;
        for(int l = 0; l < NUM_POINT_LIGHTS; l++) {
          vec3 adjustedLight = pointLights[l].position + cameraPosition;
          vec3 lightDirection = normalize(vWorldPos - adjustedLight);
          addedLights.rgb += clamp(dot(lightDirection, worldNormal), 0.0, 1.0) * pointLights[l].color;
        }

        //vec3 r = reflect(eyeDirection, worldNormal);
        vec3 r = vec3(0.5, 0.8, 1.0);
        float alpha = clamp(dot(-eyeDirection, worldNormal), 0.0, 1.0);
        vec4 c = vec4(r, 0.5 + (alpha / 2.0));
        //gl_FragColor = vec4(vColor.rgb, 0.7);
        gl_FragColor = c * addedLights;
      }
    </script>
    <script>
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
      camera.position.z = 15;
      camera.position.y = -15;
      camera.lookAt(new THREE.Vector3(0,0,0));

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );


      var defMaterial = new THREE.MeshPhongMaterial ( {
        color: 0xaaaaaa
      } );

      var sphere = new THREE.SphereGeometry( 1 );
      var lightCue = new THREE.Mesh( sphere, defMaterial );
      lightCue.position.set( 11, 11, 6 );
      scene.add(lightCue);

      var pointLight = new THREE.PointLight( 0xaaffaa, 0.8 );
      pointLight.position.set( 10, 10, 5 );
      scene.add( pointLight );

      var sphere = new THREE.SphereGeometry( 1 );
      var lightCue2 = new THREE.Mesh( sphere, defMaterial );
      lightCue2.position.set( 0, 0, 9 );
      scene.add(lightCue2);

      var pointLight2 = new THREE.PointLight( 0xffaaaa, 0.8 );
      pointLight2.position.set( 0, 0, 8 );
      scene.add( pointLight2 );

      var circularWaveStrength1 = Math.random();
      var circularWaveStrength2 = Math.random();

      // wave uniforms are basically arbitrary
      var uniforms = THREE.UniformsUtils.merge([
        THREE.UniformsLib['lights'],
        {
          time: { type: "f", value: 0.0 },
          timeFactor: { type: "f", value: 1.5 },
          amplitudeFactor: { type: "f", value: 0.5 },
          circularAmplitudeFactor: {type: "f", value: 0.02 },
          scale: { type: "f", value: 0.5 },
          wavelengths: { type: "f[]", value: [8.0, 5.0, 3.2, 2.1, 1.7, 1.3] },
          speeds: { type: "f[]", value: [0.4, 0.43, 0.47, 0.5, 0.8, 0.9] },
          amplitudes: { type: "f[]", value: [0.5, 0.45, 0.3, 0.23, 0.17, 0.05] },
          directions: { type: "v2[]", value: [
            new THREE.Vector2 ( 1.0, 0.0 ).normalize(),
            new THREE.Vector2 ( 0.5, 0.5 ).normalize(),
            new THREE.Vector2 ( 0.4, 0.7 ).normalize(),
            new THREE.Vector2 ( 0.8, 0.2 ).normalize(),
            new THREE.Vector2 ( 1.0, 0.3 ).normalize(),
            new THREE.Vector2 ( 0.0, 0.4 ).normalize()
          ] },
          circularWavelength: { type: "f", value: 1.0 },
          circularSpeed: { type: "f", value: 1.0 },
          circularWaveStrengths: { type: "f[]", value: [circularWaveStrength1, circularWaveStrength2] },
          circularWaveCenterPoints: { type: "v2[]", value: [
            new THREE.Vector2 ( 10.0, 0.0 ),
            new THREE.Vector2 ( 0.0, 5.0 )
          ] }
        }
      ]);
      
      var material = new THREE.ShaderMaterial( {
        uniforms: uniforms,
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
        transparent: true,
        lights: true
      } );   
      
      var size = 10;

      var circle = new THREE.CircleGeometry( size, 32 );

      var tessellateModifier = new THREE.TessellateModifier(.01);
      
      var tessellationDepth = 10;
      for(var i = 0; i < tessellationDepth; i++){
        tessellateModifier.modify(circle);
      }

      var pool = new THREE.Mesh( circle, material );
      scene.add( pool );

      var poolBottom = new THREE.Mesh( circle, defMaterial );
      scene.add( poolBottom );
      poolBottom.position.z = -5;

      controls = new THREE.OrbitControls( camera, renderer.domElement );

      var clock = new THREE.Clock();
      clock.start();

      function getRandomPoint() {
        dSquared = Math.random() * size * size;
        theta = Math.random() * Math.PI * 2;
        x = Math.sqrt(dSquared) * Math.cos(theta);
        y = Math.sqrt(dSquared) * Math.sin(theta);
        return new THREE.Vector2(x, y);
      }

      function render() {
        requestAnimationFrame( render );
        renderer.render( scene, camera );

        var delta = clock.getDelta();
        uniforms.time.value += delta;
        for(var i = 0; i < 2; i++){
          if(uniforms.circularWaveStrengths.value[i] > 0) {
            uniforms.circularWaveStrengths.value[i] -= (delta/10.0);
          } else {
            uniforms.circularWaveStrengths.value[i] = 1.0;
            uniforms.circularWaveCenterPoints.value[i] = getRandomPoint();
          }
        }
      }
      render();
    </script>
  </body>
</html>
